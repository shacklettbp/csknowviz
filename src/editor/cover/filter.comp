#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require

#ifdef VALIDATE 
#extension GL_EXT_debug_printf : enable
#endif

// GLSL wants this for uint64_t -> accel struct conversion
#extension GL_EXT_ray_tracing : require

#include "common.glsl"

layout (push_constant, scalar) uniform PushConstant {
    CoverPushConst push_const;
};

layout (set = 0, binding = 0) readonly buffer Positions {
    vec4 positions[];
};

layout (set = 0, binding = 1) buffer Counter {
    uint32_t numCandidates;
};

layout (set = 0, binding = 2, scalar) writeonly buffer Candidates {
    CandidatePair candidates[];
};

layout (set = 0, binding = 3, scalar) readonly buffer AABBs {
    GPUAABB aabbs[];
};

layout (set = 0, binding = 4, scalar) readonly buffer VoxelPoints {
    vec3 voxelPoints[];
};

layout (set = 0, binding = 4, scalar) writeonly buffer HitLengths {
    float hitLengths[];
};

float getAABBHitT(GPUAABB aabb, vec3 ray_origin, vec3 ray_dir)
{
    vec3 pmin = vec3(aabb.pMinX, aabb.pMinY, aabb.pMinZ);
    vec3 pmax = vec3(aabb.pMaxX, aabb.pMaxY, aabb.pMaxZ);

    vec3 inv_dir = 1.f / ray_dir;

    vec3 tmin = (pmin - ray_origin) * inv_dir;
    vec3 tmax = (pmax - ray_origin) * inv_dir;

    vec3 t = min(tmin, tmax);

    return max(max(t.x, t.y), t.z);
}

bool traceAABBRay(in rayQueryEXT ray_query,
                  in vec3 ray_origin,
                  in vec3 ray_dir,
                  in uint32_t mask)
{
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsNoneEXT, mask,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionAABBEXT) {

            GPUAABB aabb = aabbs[nonuniformEXT(
                rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, false))];

            float t = getAABBHitT(aabb, ray_origin, ray_dir);

            rayQueryGenerateIntersectionEXT(ray_query, t);
        }
    }

    subgroupBarrier();

    return rayQueryGetIntersectionTypeEXT(ray_query, true) !=
        gl_RayQueryCommittedIntersectionNoneEXT;
}

bool checkAABBHit(in vec3 ray_origin,
                  in vec3 ray_dir,
                  in uint32_t mask)
{
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsTerminateOnFirstHitEXT, mask,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    rayQueryProceedEXT(ray_query);

    return rayQueryGetIntersectionTypeEXT(ray_query, false) ==
        gl_RayQueryCandidateIntersectionAABBEXT;
}

#if 0
bool cornerRay(in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_pos)
{
    rayQueryEXT first_query;
    bool first_hit = traceRay(first_query, ray_origin, ray_dir, 3);

    float first_t = LARGE_DISTANCE;
    vec3 geo_normal;
    if (first_hit) {
        first_pos = getWorldSpaceHitCommitted(first_query);
    } else {
        first_pos = vec3(0);
    }

    subgroupBarrier();
    
    rayQueryEXT second_query;
    vec3 second_pos = vec3(0);
    bool second_hit = traceAABBRay(second_query, first_pos, ray_dir, 4);

    if (first_hit && second_hit) {
        float second_t = rayQueryGetIntersectionTEXT(second_query, true);
        second_pos = first_pos + ray_dir * second_t;
    }

    subgroupBarrier();

    float dist = distance(second_pos, first_pos);

    if (!first_hit || !second_hit || dist == 0.f) {
        return false;
    }

    return dist < epsilon;
}

bool cornerRay(in rayQueryEXT ray_query,
               in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_hit)
{
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsNoneEXT, 0xFF,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    float first_t = LARGE_DISTANCE;
    float second_t = LARGE_DISTANCE;

    vec3 second_hit;

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {
            float cur_t = rayQueryGetIntersectionTEXT(ray_query, false);

            if (cur_t < first_t) {
                second_t = first_t;
                second_hit = first_hit;

                first_t = cur_t;
                first_hit = getWorldSpaceHitUncommitted(ray_query);
            } else if (cur_t < second_t) {
                second_t = cur_t;
                second_hit = getWorldSpaceHitUncommitted(ray_query);
            }
        }
    }

    subgroupBarrier();

    if (first_t == LARGE_DISTANCE || second_t == LARGE_DISTANCE) {
        return false;
    }

    return distance(first_hit, second_hit) < epsilon;
}
#endif

void getHitPosAndIndex(in rayQueryEXT ray_query, out vec3 world_pos,
                       out uint32_t out_idx)
{
    vec2 barys;
    uint32_t tri_idx, geo_idx, mesh_offset;
    mat4x3 o2w;
    getHitParamsCommitted(ray_query, barys, tri_idx, geo_idx,
                         mesh_offset, o2w);

    MeshInfo mesh_info = unpackMeshInfo(mesh_offset + geo_idx);

    uint32_t index_offset = mesh_info.indexOffset + tri_idx * 3;
    Triangle hit_tri = fetchTriangle(index_offset);

    vec3 obj_position = interpolatePosition(hit_tri.a.position,
        hit_tri.b.position, hit_tri.c.position, barys);

    world_pos = transformPosition(o2w, obj_position);
    out_idx = index_offset;
}

layout (local_size_x = 32,
        local_size_y = 1,
        local_size_z = 1) in;
void findCandidates()
{
    uint32_t point_idx = gl_GlobalInvocationID.x + push_const.pointsPerVoxel * push_const.voxelStartIdx;
    uint32_t origin_idx = push_const.originIdx;

    if (point_idx >= push_const.numPoints ||
        origin_idx >= push_const.numGroundSamples) {
        return;
    }

    vec3 origin = positions[origin_idx].xyz;
    origin.y += push_const.agentHeight;
    vec3 voxel_point = voxelPoints[point_idx].xyz;
    vec3 origin_to_point_dir = normalize(voxel_point - origin);

    rayQueryEXT geo_query;
    bool geo_hit = traceRay(geo_query, origin, origin_to_point_dir, 3,
                            LARGE_DISTANCE);

    vec3 geo_pos;
    uint32_t geo_prim;
    if (geo_hit) {
        getHitPosAndIndex(geo_query, geo_pos, geo_prim);
    } else {
        geo_pos = vec3(0);
        geo_prim = ~0u;
    }

    subgroupBarrier();

    if (geo_hit) {
        hitLengths[point_idx] = length(geo_pos - origin);
    }
}
