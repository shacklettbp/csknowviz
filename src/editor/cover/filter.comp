#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require

#ifdef VALIDATE 
#extension GL_EXT_debug_printf : enable
#endif

// GLSL wants this for uint64_t -> accel struct conversion
#extension GL_EXT_ray_tracing : require

#include "common.glsl"

layout (push_constant, scalar) uniform PushConstant {
    CoverPushConst push_const;
};

layout (set = 0, binding = 0) readonly buffer Positions {
    vec4 positions[];
};

layout (set = 0, binding = 1) buffer Counter {
    uint32_t numCandidates;
};

layout (set = 0, binding = 2, scalar) writeonly buffer Candidates {
    CandidatePair candidates[];
};

void getWorldSpaceHitParams(in rayQueryEXT ray_query,
                            out vec3 world_pos,
                            out vec3 geo_normal,
                            out float hit_t)
{
    vec2 barys;
    uint32_t tri_idx, geo_idx, mesh_offset;
    mat4x3 o2w;
    getHitParamsCommitted(ray_query, barys, tri_idx, geo_idx,
                          mesh_offset, o2w);

    MeshInfo mesh_info = unpackMeshInfo(mesh_offset + geo_idx);

    uint32_t index_offset = mesh_info.indexOffset + tri_idx * 3;
    Triangle hit_tri = fetchTriangle(index_offset);

    vec3 obj_position = interpolatePosition(hit_tri.a.position,
        hit_tri.b.position, hit_tri.c.position, barys);

    world_pos = transformPosition(o2w, obj_position);

    vec3 obj_geo_normal = cross(
        hit_tri.c.position - hit_tri.a.position,
        hit_tri.b.position - hit_tri.a.position);

    mat4x3 w2o = rayQueryGetIntersectionWorldToObjectEXT(ray_query, true);
    geo_normal = transformNormal(w2o, obj_geo_normal);

    hit_t = rayQueryGetIntersectionTEXT(ray_query, true);
}

# if 0
bool cornerRay(in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_pos)
{
    rayQueryEXT first_query;
    bool first_hit = traceRay(first_query, ray_origin, ray_dir);

    float first_t = LARGE_DISTANCE;
    vec3 geo_normal;
    if (first_hit) {
        getWorldSpaceHitParams(first_query, first_pos, geo_normal, first_t);
    }

    vec3 offset_normal = dot(geo_normal, ray_dir) > 0 ? geo_normal : -geo_normal;
    vec3 second_launch = offsetRayOrigin(first_pos, offset_normal);

    subgroupBarrier();
    
    rayQueryEXT second_query;
    bool second_hit = traceRay(second_query, second_launch, ray_dir);

    float second_t = LARGE_DISTANCE;
    if (first_hit && second_hit) {
        second_t = rayQueryGetIntersectionTEXT(second_query, true);
    }

    subgroupBarrier();

    if (first_t == LARGE_DISTANCE || second_t == LARGE_DISTANCE) {
        return false;
    }

    return (second_t - first_t) < epsilon;
}
#endif

bool cornerRay(in rayQueryEXT ray_query,
               in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_hit)
{
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsNoneEXT, 0xFF,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    float first_t = LARGE_DISTANCE;
    float second_t = LARGE_DISTANCE;

    vec3 second_hit;

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {
            float cur_t = rayQueryGetIntersectionTEXT(ray_query, false);

            if (cur_t < first_t) {
                second_t = first_t;
                second_hit = first_hit;

                first_t = cur_t;
                first_hit = getWorldSpaceHitUncommitted(ray_query);
            } else if (cur_t < second_t) {
                second_t = cur_t;
                second_hit = getWorldSpaceHitUncommitted(ray_query);
            }
        }
    }

    subgroupBarrier();

    if (first_t == LARGE_DISTANCE || second_t == LARGE_DISTANCE) {
        return false;
    }

    return distance(first_hit, second_hit) < epsilon;
}

layout (local_size_x = 8,
        local_size_y = 4,
        local_size_z = 1) in;
void findCandidates()
{
    uint32_t idx = gl_GlobalInvocationID.z + push_const.idxOffset;
    uint32_t x_sphere = gl_GlobalInvocationID.x;
    uint32_t y_sphere = gl_GlobalInvocationID.y;

    if (idx >= push_const.numGroundSamples ||
        x_sphere >= push_const.sqrtSphereSamples ||
        y_sphere >= push_const.sqrtSphereSamples) {
        return;
    }
    
    vec3 base_origin = positions[idx].xyz + push_const.agentHeight;

    vec2 uv = vec2(float(x_sphere) / (push_const.sqrtSphereSamples - 1),
                   float(y_sphere) / (push_const.sqrtSphereSamples - 1));

    vec3 dir = sphereDir(uv);

    // FIXME: add jitter
    vec3 origin = base_origin; //+ push_const.originJitter;

    rayQueryEXT ray_query;
    vec3 corner_pos;
    bool valid_corner = cornerRay(ray_query, origin, normalize(dir),
                                  push_const.cornerEpsilon,
                                  corner_pos);

    if (valid_corner) {
        CandidatePair candidate;
        candidate.origin = origin;
        candidate.candidate = corner_pos;

        uint32_t out_idx = atomicAdd(numCandidates, 1);

        candidates[out_idx] = candidate;
    }
}
