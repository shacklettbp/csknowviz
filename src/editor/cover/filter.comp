#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require

#ifdef VALIDATE 
#extension GL_EXT_debug_printf : enable
#endif

// GLSL wants this for uint64_t -> accel struct conversion
#extension GL_EXT_ray_tracing : require

#include "common.glsl"

layout (push_constant, scalar) uniform PushConstant {
    CoverPushConst push_const;
};

layout (set = 0, binding = 0) readonly buffer Positions {
    vec4 positions[];
};

layout (set = 0, binding = 1) buffer Counter {
    uint32_t numCandidates;
};

layout (set = 0, binding = 2) writeonly buffer Candidates {
    CandidatePair candidates[];
};

bool cornerRay(in rayQueryEXT ray_query,
               in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_hit)
{
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsNoneEXT, 0xFF,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    float first_t = LARGE_DISTANCE;
    float second_t = LARGE_DISTANCE;

    vec3 second_hit;

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {
            float cur_t = rayQueryGetIntersectionTEXT(ray_query, false);

            if (cur_t < first_t) {
                second_t = first_t;
                second_hit = first_hit;

                first_t = cur_t;
                first_hit = getWorldSpaceHit(ray_query, false);
            } else if (cur_t < second_t) {
                second_t = cur_t;
                second_hit = getWorldSpaceHit(ray_query, false);
            }
        }
    }

    subgroupBarrier();

    if (first_t == LARGE_DISTANCE || second_t == LARGE_DISTANCE) {
        return false;
    }

    return distance(first_hit, second_hit) < epsilon;
}

layout (local_size_x = 32,
        local_size_y = 1,
        local_size_z = 1) in;
void findCandidates()
{
    uint32_t idx = gl_GlobalInvocationID.x;

    if (idx >= push_const.numGroundSamples) {
        return;
    }

    vec3 base_origin = positions[idx].xyz + push_const.agentHeight;

    for (int i = 0; i < push_const.sqrtSphereSamples; i++) {
        for (int j = 0; j < push_const.sqrtSphereSamples; j++) {
            vec2 uv = vec2(i / (push_const.sqrtSphereSamples - 1),
                           j / (push_const.sqrtSphereSamples - 1));

            vec3 dir = sphereDir(uv);

            // FIXME: add jitter
            vec3 origin = base_origin; //+ push_const.originJitter;

            rayQueryEXT query;
            vec3 corner_pos;
            bool valid_corner = cornerRay(query, origin, dir,
                                          push_const.cornerEpsilon,
                                          corner_pos);

            subgroupBarrier();

            if (valid_corner) {
                CandidatePair candidate;
                candidate.origin = origin;
                candidate.candidate = corner_pos;

                uint32_t out_idx = atomicAdd(numCandidates, 1);

                candidates[out_idx] = candidate;
            }

            subgroupBarrier();
        }
    }
}
