#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require

#ifdef VALIDATE 
#extension GL_EXT_debug_printf : enable
#endif

// GLSL wants this for uint64_t -> accel struct conversion
#extension GL_EXT_ray_tracing : require

#include "common.glsl"

layout (push_constant, scalar) uniform PushConstant {
    CoverPushConst push_const;
};

layout (set = 0, binding = 0) readonly buffer Positions {
    vec4 positions[];
};

layout (set = 0, binding = 1) buffer Counter {
    uint32_t numCandidates;
};

layout (set = 0, binding = 2, scalar) writeonly buffer Candidates {
    CandidatePair candidates[];
};

layout (set = 0, binding = 3, scalar) readonly buffer AABBs {
    GPUAABB aabbs[];
};

float getAABBHitT(GPUAABB aabb, vec3 ray_origin, vec3 ray_dir)
{
    vec3 pmin = vec3(aabb.pMinX, aabb.pMinY, aabb.pMinZ);
    vec3 pmax = vec3(aabb.pMaxX, aabb.pMaxY, aabb.pMaxZ);

    vec3 inv_dir = 1.f / ray_dir;

    vec3 tmin = (pmin - ray_origin) * inv_dir;
    vec3 tmax = (pmax - ray_origin) * inv_dir;

    vec3 t = min(tmin, tmax);

    return max(max(t.x, t.y), t.z);
}

bool traceAABBRay(in rayQueryEXT ray_query,
                  in vec3 ray_origin,
                  in vec3 ray_dir,
                  in uint32_t mask)
{
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsNoneEXT, mask,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionAABBEXT) {

            GPUAABB aabb = aabbs[nonuniformEXT(
                rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, false))];

            float t = getAABBHitT(aabb, ray_origin, ray_dir);

            rayQueryGenerateIntersectionEXT(ray_query, t);
        }
    }

    subgroupBarrier();

    return rayQueryGetIntersectionTypeEXT(ray_query, true) !=
        gl_RayQueryCommittedIntersectionNoneEXT;
}

bool cornerRay(in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_pos)
{
    rayQueryEXT first_query;
    bool first_hit = traceRay(first_query, ray_origin, ray_dir, 3);

    float first_t = LARGE_DISTANCE;
    vec3 geo_normal;
    if (first_hit) {
        first_pos = getWorldSpaceHitCommitted(first_query);
    } else {
        first_pos = vec3(0);
    }

    subgroupBarrier();
    
    rayQueryEXT second_query;
    vec3 second_pos = vec3(0);
    bool second_hit = traceAABBRay(second_query, first_pos, ray_dir, 4);

    if (first_hit && second_hit) {
        float second_t = rayQueryGetIntersectionTEXT(second_query, true);
        second_pos = first_pos + ray_dir * second_t;
    }

    subgroupBarrier();

    float dist = distance(second_pos, first_pos);

    if (!first_hit || !second_hit || dist == 0.f) {
        return false;
    }

    return dist < epsilon;
}

#if 0
bool cornerRay(in rayQueryEXT ray_query,
               in vec3 ray_origin,
               in vec3 ray_dir,
               in float epsilon,
               out vec3 first_hit)
{
    rayQueryInitializeEXT(ray_query, tlas,
                          gl_RayFlagsNoneEXT, 0xFF,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    float first_t = LARGE_DISTANCE;
    float second_t = LARGE_DISTANCE;

    vec3 second_hit;

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {
            float cur_t = rayQueryGetIntersectionTEXT(ray_query, false);

            if (cur_t < first_t) {
                second_t = first_t;
                second_hit = first_hit;

                first_t = cur_t;
                first_hit = getWorldSpaceHitUncommitted(ray_query);
            } else if (cur_t < second_t) {
                second_t = cur_t;
                second_hit = getWorldSpaceHitUncommitted(ray_query);
            }
        }
    }

    subgroupBarrier();

    if (first_t == LARGE_DISTANCE || second_t == LARGE_DISTANCE) {
        return false;
    }

    return distance(first_hit, second_hit) < epsilon;
}
#endif

layout (local_size_x = 8,
        local_size_y = 4,
        local_size_z = 1) in;
void findCandidates()
{
    uint32_t idx = gl_GlobalInvocationID.z + push_const.idxOffset;
    uint32_t x_sphere = gl_GlobalInvocationID.x;
    uint32_t y_sphere = gl_GlobalInvocationID.y;

    if (idx >= push_const.numGroundSamples ||
        x_sphere >= push_const.sqrtSphereSamples ||
        y_sphere >= push_const.sqrtSphereSamples) {
        return;
    }
    
    vec3 base_origin = positions[idx].xyz;
    base_origin.y += push_const.agentHeight;

    vec2 uv = vec2(float(x_sphere) / (push_const.sqrtSphereSamples - 1),
                   float(y_sphere) / (push_const.sqrtSphereSamples - 1));

    vec3 dir = sphereDir(uv);

    // FIXME: add jitter
    vec3 origin = base_origin; //+ push_const.originJitter;

    rayQueryEXT ray_query;
    vec3 corner_pos;
    bool valid_corner = cornerRay(origin, normalize(dir),
                                  push_const.cornerEpsilon,
                                  corner_pos);

    if (valid_corner) {
        CandidatePair candidate;
        candidate.origin = origin;
        candidate.candidate = corner_pos;

        uint32_t out_idx = atomicAdd(numCandidates, 1);

        candidates[out_idx] = candidate;
    }
}
